package main

import "fmt"

/*
Реализовать паттерн «адаптер» на любом примере.
*/

/*
Класс Adapter приводит интерфейс класса Adaptee в соответствие с интерфейсом класса Target
(который реализуется классом Adapter). Это позволяет объекту Client использовать объект
Adaptee (посредством адаптера Adapter) так, словно он является экземпляром класса Target.
Таким образом Client обращается к интерфейсу Target, реализованному классом Adapter,
который перенаправляет обращение к Adaptee.
Адаптер(Adapter) - структурный шаблон проектирования,
предназначенный для организации использования функции объекта,
недоступно для модификаций, через специально созданный интерфейс
Решаемая проблема:
У нас уже есть конкретная структура и нужно,
чтобы эта структура реализовывала определенный интерфейс,
при этом структуру менять нельзя
*/

// target
// Интерфейс Animal, элементы которого должны имплементировать метод Voice()
type Animal interface {
	Voice() string
}

// Класс - адаптер для класса Cat, который имплементирует метод Voice() вызывая аналогичный метод у
// класса CAt
type Adapter struct {
	*Cat
}

func (a Adapter) Voice() string {
	return a.Meow()
}

// adaptee
// Класс, для которого мы пишем класс-адаптер, чтобы он удовлетворял интерфейсу Animal
type Cat struct {
}

func (a Cat) Meow() string {
	return "meow"
}

func MakeSound(a Animal) {
	fmt.Print(a.Voice())
}

func main() {
	cat := &Cat{}
	adapter := Adapter{cat}
	MakeSound(adapter)
}
