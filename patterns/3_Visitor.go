package main

import "fmt"

/*
Паттерн Visitor определяет операцию, выполняемую на каждом
элементе из некоторой структуры. Позволяет, не изменяя классы этих объектов,
добавлять в них новые операции.

1. Посетитель описывает общий интерфейс для всех типов посетителей.
Он объявляет набор методов, отличающихся типом входящего параметра,
которые нужны для запуска операции для всех типов конкретных элементов.
В языках, поддерживающих перегрузку методов, эти методы могут иметь одинаковые имена,
но типы их параметров должны отличаться.
2. Конкретные посетители реализуют какое-то особенное поведение для всех типов элементов,
которые можно подать через методы интерфейса посетителя.
3. Элемент описывает метод принятия посетителя. Этот метод должен иметь единственный параметр,
объявленный с типом интерфейса посетителя.
4. Конкретные элементы реализуют методы принятия посетителя. Цель этого метода –
вызвать тот метод посещения, который соответствует типу этого элемента. Так посетитель
узнает, с каким именно элементом он работает.
5. Клиентом зачастую выступает коллекция или сложный составной объект, например,
дерево Компоновщика. Зачастую клиент не привязан к конкретным классам элементов,
работая с ними через общий интерфейс элементов.

Плюсы:
- новая функциональность в несколько классов добавляется сразу, не изменяя код этих классов;
- позволяет получить информацию о типе объекта;

Минусы:
- при изменении обслуживаемого класса нужно поменять код у шаблона;
- затруднено добавление новых классов, поскольку нужно обновлять иерархию посетителя и его сыновей.

Пример использования:
Необходимо сделать какие-то несвязные операции над рядом объектов, но нужно избежать
загрязнения их кода. И нет возможности или желания запрашивать тип каждого узла и
осуществлять приведение указателя к правильному типу, прежде чем выполнить нужную операцию.
*/

type Visitor interface {
	EatApple(a *Apple) string
	EatOrange(o *Orange) string
}

type Fruit interface {
	Accept(v Visitor) string
}

type ConcreteVisitor struct {
}

func (c *ConcreteVisitor) EatApple(a *Apple) string {
	return a.Apple()
}

func (c *ConcreteVisitor) EatOrange(o *Orange) string {
	return o.Orange()
}

type Apple struct {
}

func (a *Apple) Apple() string {
	return "apple"
}

func (a *Apple) Accept(v Visitor) string {
	return v.EatApple(a)
}

type Orange struct {
}

func (o *Orange) Orange() string {
	return "orange"
}

func (o *Orange) Accept(v Visitor) string {
	return v.EatOrange(o)
}

func main() {
	// make queue of objects for visitor
	fruits := []Fruit{&Orange{}, &Apple{}}
	for _, fr := range fruits {
		cv := ConcreteVisitor{}
		fmt.Println(fr.Accept(&cv))
	}
}
