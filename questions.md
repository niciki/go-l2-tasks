# 1. Что выведет программа? Объяснить вывод программы.
```go
package main
 
import (
    "fmt"
)
 
func main() {
    a := [5]int{76, 77, 78, 79, 80}
    var b []int = a[1:4]
    fmt.Println(b)
}
```
Программа выведет: ```[77, 78, 79]``` в слайс `b` положится слайс массива `а` с 1ого по 4ый индекс не включительно.
# 2. Что выведет программа? Объяснить вывод программы. Объяснить как работают defer’ы и порядок их вызовов.
```go
package main
 
import (
    "fmt"
)
 
func test() (x int) {
    defer func() {
        x++
    }()
    x = 1
    return
}
 
 
func anotherTest() int {
    var x int
    defer func() {
        x++
    }()
    x = 1
    return x
}
 
 
func main() {
    fmt.Println(test())
    fmt.Println(anotherTest())
}
```
Будет выведено 2 и 1. `defer` - оператор отложенного вызова, который выполняется после завершения работы функции. 
Если в функции несколько раз вызывается `defer`, то их вызов работает по принципу LIFO(по принципу стека), так как вызовы помещаются в стек, 
они производятся в порядке от последнего к первому.<br/>
В функции `test` мы возвращаем именнованное поле, поэтому, проинициализировав переменную `x` изначально 1, после завершения функции в `defer` мы инкрементируем
значение х, адрес которого нам известен. Во втором же случае после возврата значения мы будем инкрементировать его копию, поэтому будет возвращено значение 1.

# 3. Что выведет программа? Объяснить вывод программы. Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов.
```go
package main
 
import (
    "fmt"
    "os"
)
 
func Foo() error {
    var err *os.PathError = nil
    return err
}
 
func main() {
    err := Foo()
    fmt.Println(err)
    fmt.Println(err == nil)
}
```
Будет выведено ```<nil> false```. Указатель в го - пара, содержащее тип, на который указывае указатель и адрес в памяти. Значение интерфейса равно `nil` только когда и значtние, и динамический тип - `nil`.
В примере `Foo()` возвращает `[nil, *os.PathError]`, а сравниваем мы это с `[nil, nil]`.
Для корректного сравнения можно было бы возвращать `*os.PathError` из функции.

# 4. Что выведет программа? Объяснить вывод программы.
```go
package main
 
func main() {
    ch := make(chan int)
    go func() {
        for i := 0; i < 10; i++ {
            ch <- i
        }
    }()
 
    for n := range ch {
        println(n)
    }
}
```
Будут выведены цифры от 0 до 9, а затем сообщение о `deadlock`. Это произойдет потому, что в горутине мы последовательно пишем в канал цифры,
а в цикле читаем их. После записи всех чисел в цикле будет ожидаться очередная запись числа в канал. Канал необходимо было закрыть в горутине, чтобы
цикл `for` считывания автоматически завершился. 

# 5. Что выведет программа? Объяснить вывод программы.
```go
package main
 
type customError struct {
     msg string
}
 
func (e *customError) Error() string {
    return e.msg
}
 
func test() *customError {
     {
         // do something
     }
     return nil
}
 
func main() {
    var err error
    err = test()
    if err != nil {
        println("error")
        return
    }
    println("ok")
}
```
Будет выведено `error`. Этот пример похож на 3. в данном случае мы реализовали интерфейс `error` типом `customError`. Функция `test()` возвращает тип 
`*customError`. Поэтому, при сравнении переменной `err` сравниваться будут следующие пары: `[*customError, nil]` и `[*customError, nil]`, что есть 
`true`, поэтому и выведется  `error`. Если же в функции `test()` возвращался бы тип `error`, как в вопросе 3, то вывод был бы "ok".

# 6. Что выведет программа? Объяснить вывод программы. Рассказать про внутреннее устройство слайсов и что происходит при передаче их в качестве аргументов функции.
```go
package main
 
import (
  "fmt"
)
 
func main() {
  var s = []string{"1", "2", "3"}
  modifySlice(s)
  fmt.Println(s)
}
 
func modifySlice(i []string) {
  i[0] = "3"
  i = append(i, "4")
  i[1] = "5"
  i = append(i, "6")
}
```
Будет выведено `[3 2 3]`. Слайс - это структура данных, которая состоит из указателя на массив, длины сегмента и его вместимости (максимальной длины сегмента).
При передачи слайся в функцию, копирование слайса не копирует массив, но позволяет изменять массив, так как слайс хранит указатель на него.
В функции мы операцией `i[0] = "3"` меняем значение массива, которое лежит под указателем. Далее, после выполнения функции `append` в переменной `i` хранится 
уже указатель на другой массив, поэтому все изменения последующие никак не повлияют на наш слайс, который мы выводим в функции `main`

